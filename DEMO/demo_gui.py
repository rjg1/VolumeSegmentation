import tkinter as tk
from tkinter import ttk, messagebox
import json
import os
import subprocess
import queue
import threading
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import tifffile

# Relative path to scenarios json
SCENARIOS_PATH = "./scenarios.json"
# Outlines of masks generated by cellpose on a DRG dataset
RAW_DATA_PATH = "../GUI/cell_data/roi_coordinates_2.csv"
# Outlines of masks generated by cellpose on a DRG dataset, after which a pre-processing merge step was applied
MERGED_DATA_PATH = "../GUI/cell_data/ROI_coordinates_20241003_x300_800_y0_500_z1_38.csv"
# Path to cell merger tool
CELL_MERGER_PATH = "../GUI/cell_merger.py"
# Path to volume segmenter tool
VOLUME_SEGMENTER_PATH = "../GUI/manual_seg.py"
# Force new scenarios to reduce data first
FORCE_REQUIRE_REDUCED_DATA = True
# Save scenarios json on close
SAVE_SCENARIOS_ON_CLOSE = True
# Data paths to default data used
DEFAULT_DATA_PATHS = [RAW_DATA_PATH, MERGED_DATA_PATH]
# Maximum number of points to sample for raw data viewer
MAX_SAMPLE_POINTS = 15000
# Whether to draw some z-slices of the original .tif file on the raw data
SHOW_Z_SLICES = False
# Maximum label width for info display
MAX_LABEL_WIDTH = 20
# Default FFP segmentation parameters
USE_FLAT_CENTROID = True
USE_PERC_CENTROID = False
USE_Z_THRESHOLD = True
USE_AREA_RESTRICTION = False
USE_XY_RESTRICTION = True
NUM_PROJECTION_POINTS = 300
FLAT_CENTROID_DIST = 10
PERC_CENTROID_DIST = 68
MATCH_Z_THRESHOLD = 4
AREA_DELTA_PERC = 150
AR_CHANGE_PERC = 30                     # Maximum allowed change in average area per ROI over a number of ROI additions
AR_CHANGE_NUM_SAMPLES = 2               # Number of xy roi samples that are considered when comparing change in average area per roi for a volume
AR_CHANGE_ACTIVATION_THRESH = 10        # Number of XY ROIs required in a volume before area restriction kicks in
RESTRICT_AREA_CHANGE = False            # Restriction on how fast a volume's average area per ROI can change

class DemoGUIApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Scenario Manager")
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.result_queue = queue.Queue()  # For thread results
        # Get the scenarios dictionary
        self.scenarios = self.load_scenarios_from_json(SCENARIOS_PATH)
        self.active_scenario = None # No active scenario on startup

        # 3D Playground section
        self.create_label = tk.Label(self.root, text="3D Playground", font=("Arial", 12, "bold"))
        self.create_label.grid(row=0, column=0, padx=5, pady=10, sticky="w")

        # Create 3D Playground Button
        self.create_button = tk.Button(self.root, text="Open Playground", command=self.open_playground, width=15)
        self.create_button.grid(row =1, padx=5, pady=1, sticky="w")
        
        # Create scenario section
        self.create_label = tk.Label(self.root, text="Create Scenario", font=("Arial", 12, "bold"))
        self.create_label.grid(row=2, column=0, padx=5, pady=10, sticky="w")

        # Create a frame to hold the entry, checkboxes, and button
        self.entry_checkbox_frame = tk.Frame(self.root)
        self.entry_checkbox_frame.grid(row=3, column=0, columnspan=4, padx=5, pady=5, sticky="w")

        # Create scenario name entry inside the frame
        self.scenario_entry = tk.Entry(self.entry_checkbox_frame, width=30)
        self.scenario_entry.pack(side="left", padx=1, pady=1)
        
        # Checkbox for using merged data inside the frame
        self.check_var = tk.IntVar(value=1)
        self.scenario_checkbox = tk.Checkbutton(self.entry_checkbox_frame, text="Use pre-processed data", variable=self.check_var)
        self.scenario_checkbox.pack(side="left", padx=1, pady=1)

        # Checkbox for requiring data to be reduced inside the frame
        self.reduce_var = tk.IntVar(value=1)
        self.reduce_checkbox = tk.Checkbutton(self.entry_checkbox_frame, text="Segmentation of validated ROIs only", variable=self.reduce_var)
        self.reduce_checkbox.pack(side="left", padx=1, pady=1)
        if FORCE_REQUIRE_REDUCED_DATA:
            self.reduce_checkbox.config(state='disabled')

        # Create button inside the frame
        self.create_button = tk.Button(self.entry_checkbox_frame, text="Create", command=self.create_scenario, width=10)
        self.create_button.pack(side="left", padx=5, pady=1)

        # Load scenario section
        self.load_label = tk.Label(self.root, text="Load Scenario", font=("Arial", 12, "bold"))
        self.load_label.grid(row=4, column=0, padx=5, pady=10, sticky="w")

        # Create a frame to hold the dropdown and load button
        self.dropdown_frame = tk.Frame(self.root)
        self.dropdown_frame.grid(row=5, column=0, columnspan=3, padx=5, pady=5, sticky="w")

        # Dropdown for loading scenario inside the frame
        self.scenario_combobox = ttk.Combobox(self.dropdown_frame, values=list(self.scenarios.keys()), width=27)
        self.scenario_combobox.pack(side="left", padx=1, pady=1)
        self.scenario_combobox.set('')  # Placeholder text
        self.scenario_combobox.bind("<KeyRelease>", self.update_dropdown)

        # Load button inside the frame
        self.load_button = tk.Button(self.dropdown_frame, text="Load", command=self.load_scenario, width=10)
        self.load_button.pack(side="left", padx=5, pady=1)
        
        # Label for active scenario
        self.active_scenario_label = tk.Label(self.root, text="No Active Scenario", font=("Arial", 12, "bold"))
        self.active_scenario_label.grid(row=6, column=0, padx=10, pady=5, sticky="w")

        # Outer frame (contains the inner left/right frames)
        self.outer_frame = ttk.Frame(self.root, width=600, height=300, relief=tk.SUNKEN)
        self.outer_frame.grid(row=7, column=0, columnspan=3, padx=5, pady=5, sticky="nsew")

        # Inner left frame (contains keys/values, split into two subframes)
        self.inner_left_frame = tk.Frame(self.outer_frame, width=400)  # Fixed width
        self.inner_left_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        # Inner right frame (options, placeholder for now)
        self.inner_right_frame = tk.Frame(self.outer_frame, width=200)  # Fixed width
        self.inner_right_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")

        # Split inner left frame into two subframes for keys and values
        self.left_info_frame = tk.Frame(self.inner_left_frame, width=200)
        self.left_info_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        self.right_info_frame = tk.Frame(self.inner_left_frame, width=200)
        self.right_info_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")

        # Configure grid to ensure proper layout
        self.outer_frame.grid_columnconfigure(0, weight=1)
        self.outer_frame.grid_columnconfigure(1, weight=1)

        # Upper and lower frame inside the right inner frame (for tools and commands)
        self.upper_right_frame = tk.Frame(self.inner_right_frame, width=200)
        self.upper_right_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        self.upper_right_frame.grid_remove()  # Hide initially

        self.lower_right_frame = tk.Frame(self.inner_right_frame, width=200)
        self.lower_right_frame.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")
        self.lower_right_frame.grid_remove()  # Hide initially

        # Upper frame content (Tools label and buttons)
        tools_label = tk.Label(self.upper_right_frame, text="Tools", font=("Arial", 12, "bold"))
        tools_label.grid(row=0, column=0, padx=10, pady=5)

        self.upper_right_frame.grid_columnconfigure(0, weight=1)

        self.data_view_button = tk.Button(self.upper_right_frame, text="Raw Data Viewer", width=15, command=self.generate_data_plot)
        self.data_view_button.grid(row=1, column=0, padx=5, pady=2, sticky="ew") 

        self.cell_merger_button = tk.Button(self.upper_right_frame, text="Cell Merger", width=15, command=self.cell_merger_tool)
        self.cell_merger_button.grid(row=2, column=0, padx=5, pady=2, sticky="ew")  

        self.volume_segmenter_button = tk.Button(self.upper_right_frame, text="Volume Segmenter", width=15, command=self.volume_segmenter_tool)
        self.volume_segmenter_button.grid(row=3, column=0, padx=5, pady=2, sticky="ew")  

        # Checkbox for requiring data to be reduced inside the frame
        self.merge_var = tk.IntVar(value=1)
        self.merge_checkbox = tk.Checkbutton(self.upper_right_frame, text="Merge ROIs on exit", variable=self.merge_var)
        self.merge_checkbox.grid(row=4, column=0, padx=5, pady=0, sticky="ew")

        # Filter/reduce data button
        self.reduce_data_button = tk.Button(self.upper_right_frame, text="Reduce Data", width=15, command=self.reduce_data)
        self.reduce_data_button.grid(row=5, column=0, padx=5, pady=2, sticky="ew")  

        # Lower frame content (Commands label, checkboxes, and execute button)
        commands_label = tk.Label(self.lower_right_frame, text="Commands", font=("Arial", 12, "bold"))
        commands_label.grid(row=0, column=0, padx=10, pady=5)

        self.lower_right_frame.grid_columnconfigure(0, weight=1)

        # Checkboxes for different commands
        self.ffp_var = tk.IntVar()
        self.seg_var = tk.IntVar()
        self.gt_var = tk.IntVar()
        self.algo_var = tk.IntVar()
        self.remake_xz = tk.IntVar()
        self.run_reduced_var = tk.IntVar()
        self.mapping_var = tk.IntVar()

        seg_label = tk.Label(self.lower_right_frame, text="Segmentation Options", font=("Arial", 10, "bold"))
        seg_label.grid(row=1, column=0, padx=10, pady=5)

        self.run_reduce_checkbox = tk.Checkbutton(self.lower_right_frame, text="Only Segment Validated ROIs", variable=self.run_reduced_var, command=self.update_scenario_from_checkboxes)
        self.run_reduce_checkbox.grid(row=2, column=0, sticky="w", padx=5, pady=2)

        self.ffp_checkbox = tk.Checkbutton(self.lower_right_frame, text="Use Fit-For-Purpose Algorithm", variable=self.ffp_var, command=self.update_scenario_from_checkboxes)
        self.ffp_checkbox.grid(row=3, column=0, sticky="w", padx=5, pady=2)

        # ALGORITHM PARAMETERS
        self.algorithm_frame = tk.Frame(self.outer_frame)
        self.algorithm_frame.grid(row=0, column=2, padx=5, pady=15, sticky="new", columnspan=2)
        self.algorithm_frame.grid_remove()  # Hide initially
        
        # Create the header label outside the container frame
        label = tk.Label(self.algorithm_frame, text="Algorithm Parameters", font=("Arial", 12, "bold"))
        label.grid(row=0, column=0, columnspan=2, padx=5, pady=10, sticky="ew")

        # Create a LabelFrame
        self.algorithm_container_frame = tk.LabelFrame(self.algorithm_frame, padx=10, pady=10)  # No text for the label frame
        self.algorithm_container_frame.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # Row 1: Entry + Checkbox
        self.flat_centroid_entry_var = tk.StringVar()  # Use StringVar to track changes
        self.flat_centroid_entry = tk.Entry(self.algorithm_container_frame, width=5, textvariable=self.flat_centroid_entry_var)
        self.flat_centroid_entry.grid(row=1, column=0, padx=5, pady=2, sticky="ew")
        self.flat_centroid_entry.bind("<Return>", self.update_algo_parameters) 

        self.flat_centroid_check_var = tk.IntVar()  # Variable for Checkbutton
        self.flat_centroid_check = tk.Checkbutton(self.algorithm_container_frame, text="Flat centroid distance", variable=self.flat_centroid_check_var,  command=lambda: self.update_algo_parameters(checkbox_name="flat"))
        self.flat_centroid_check.grid(row=1, column=1, padx=5, pady=2, sticky="w")

        # Row 2: Entry + Checkbox
        self.perc_centroid_entry_var = tk.StringVar()
        self.perc_centroid_entry = tk.Entry(self.algorithm_container_frame, width=5, textvariable=self.perc_centroid_entry_var)
        self.perc_centroid_entry.grid(row=2, column=0, padx=5, pady=2, sticky="ew")
        self.perc_centroid_entry.bind("<Return>", self.update_algo_parameters) 

        self.perc_centroid_check_var = tk.IntVar()
        self.perc_centroid_check = tk.Checkbutton(self.algorithm_container_frame, text="Percent radius centroid distance", variable=self.perc_centroid_check_var,  command=lambda: self.update_algo_parameters(checkbox_name="perc"))
        self.perc_centroid_check.grid(row=2, column=1, padx=5, pady=2, sticky="w")

        # Row 3: Entry + Checkbox
        self.match_z_entry_var = tk.StringVar()
        self.match_z_entry = tk.Entry(self.algorithm_container_frame, width=5, textvariable=self.match_z_entry_var)
        self.match_z_entry.grid(row=3, column=0, padx=5, pady=2, sticky="ew")
        self.match_z_entry.bind("<Return>", self.update_algo_parameters) 

        self.match_z_check_var = tk.IntVar()
        self.match_z_check = tk.Checkbutton(self.algorithm_container_frame, text="Z gap maximum", variable=self.match_z_check_var, command=self.update_algo_parameters)
        self.match_z_check.grid(row=3, column=1, padx=5, pady=2, sticky="w")

        # Row 4: Entry + Checkbox
        self.restrict_area_entry_var = tk.StringVar()
        self.restrict_area_entry = tk.Entry(self.algorithm_container_frame, width=5, textvariable=self.restrict_area_entry_var)
        self.restrict_area_entry.grid(row=4, column=0, padx=5, pady=2, sticky="ew")
        self.restrict_area_entry.bind("<Return>", self.update_algo_parameters) 

        self.restrict_area_check_var = tk.IntVar()
        self.restrict_area_check = tk.Checkbutton(self.algorithm_container_frame, text="Restrict area delta percent", variable=self.restrict_area_check_var, command=self.update_algo_parameters)
        self.restrict_area_check.grid(row=4, column=1, padx=5, pady=2, sticky="w")

        # Row 5: Entry + Label
        self.num_points_entry_var = tk.StringVar()
        self.num_points_entry = tk.Entry(self.algorithm_container_frame, width=5, textvariable=self.num_points_entry_var)
        self.num_points_entry.grid(row=5, column=0, padx=5, pady=2, sticky="ew")
        self.num_points_entry.bind("<Return>", self.update_algo_parameters) 

        label = tk.Label(self.algorithm_container_frame, text="Number of points to project")
        label.grid(row=5, column=1, padx=5, pady=2, sticky="w")

        # Row 6: Checkbox
        self.xy_restrict_check_var = tk.IntVar()
        self.xy_restrict_check = tk.Checkbutton(self.algorithm_container_frame, text="One XY ROI per z-level per volume", variable=self.xy_restrict_check_var, command=self.update_algo_parameters)
        self.xy_restrict_check.grid(row=6, column=0, columnspan=2, padx=5, pady=2, sticky="w")
        # Row 7: Entry>Label Entry>Label Entry>Label >Checkbox
        # Create a frame for the experimental area derivative restriction
        self.experimental_area_frame = tk.LabelFrame(self.algorithm_frame, text="Experimental Area Derivative Restriction", padx=10, pady=10)
        self.experimental_area_frame.grid(row=7, column=0, columnspan=6, padx=5, pady=5, sticky="ew")

        # Percent difference entry + label
        self.percent_diff_entry_var = tk.StringVar()
        self.percent_diff_entry = tk.Entry(self.experimental_area_frame, width=5, textvariable=self.percent_diff_entry_var)
        self.percent_diff_entry.grid(row=0, column=0, padx=5, pady=2, sticky="ew")
        self.percent_diff_entry.bind("<Return>", self.update_algo_parameters)

        percent_diff_label = tk.Label(self.experimental_area_frame, text="Percent diff in area between volume and subset of ROIs", wraplength=200)
        percent_diff_label.grid(row=0, column=1, padx=5, pady=2, sticky="w")

        # Number of XY ROIs to compare entry + label
        self.num_xy_rois_entry_var = tk.StringVar()
        self.num_xy_rois_entry = tk.Entry(self.experimental_area_frame, width=5, textvariable=self.num_xy_rois_entry_var)
        self.num_xy_rois_entry.grid(row=1, column=0, padx=5, pady=2, sticky="ew")
        self.num_xy_rois_entry.bind("<Return>", self.update_algo_parameters)

        num_xy_rois_label = tk.Label(self.experimental_area_frame, text="Subset number of XY ROIs to compare", wraplength=200)
        num_xy_rois_label.grid(row=1, column=1, padx=5, pady=2, sticky="w")

        # Minimum samples required entry + label 
        self.min_samples_entry_var = tk.StringVar()
        self.min_samples_entry = tk.Entry(self.experimental_area_frame, width=5, textvariable=self.min_samples_entry_var)
        self.min_samples_entry.grid(row=3, column=0, padx=5, pady=2, sticky="ew")
        self.min_samples_entry.bind("<Return>", self.update_algo_parameters)

        min_samples_label = tk.Label(self.experimental_area_frame, text="Min ROIs per volume before enabled", wraplength=200)
        min_samples_label.grid(row=3, column=1, padx=5, pady=2, sticky="w")

        # Enable mode checkbox
        self.enable_mode_check_var = tk.IntVar()
        self.enable_mode_check = tk.Checkbutton(self.experimental_area_frame, text="Enable restriction", variable=self.enable_mode_check_var, command=self.update_algo_parameters)
        self.enable_mode_check.grid(row=4, column=0, columnspan=2, padx=5, pady=2, sticky="w")


        # END algorithm options
        self.xz_checkbox = tk.Checkbutton(self.lower_right_frame, text="Regenerate XZ Planes", variable=self.remake_xz, command=self.update_scenario_from_checkboxes)
        self.xz_checkbox.grid(row=5, column=0, sticky="w", padx=5, pady=2)

        self.seg_checkbox = tk.Checkbutton(self.lower_right_frame, text="Run Volume Segmentation", variable=self.seg_var, command=self.update_scenario_from_checkboxes)
        self.seg_checkbox.grid(row=6, column=0, sticky="w", padx=5, pady=2)

        plot_label = tk.Label(self.lower_right_frame, text="Plot Options", font=("Arial", 10, "bold"))
        plot_label.grid(row=7, column=0, padx=10, pady=5)

        self.gt_checkbox = tk.Checkbutton(self.lower_right_frame, text="View Ground Truth Volumes", variable=self.gt_var, command=self.update_scenario_from_checkboxes)
        self.gt_checkbox.grid(row=8, column=0, sticky="w", padx=5, pady=2)

        self.algo_checkbox = tk.Checkbutton(self.lower_right_frame, text="View Algorithmic Volumes", variable=self.algo_var, command=self.update_scenario_from_checkboxes)
        self.algo_checkbox.grid(row=9, column=0, sticky="w", padx=5, pady=2)

        self.mapping_checkbox = tk.Checkbutton(self.lower_right_frame, text="Re-map Volumes", variable=self.mapping_var, command=self.update_scenario_from_checkboxes)
        self.mapping_checkbox.grid(row=10, column=0, sticky="w", padx=5, pady=2)

        # Execute button with fixed width
        self.execute_button = tk.Button(self.lower_right_frame, text="Execute", width=15, command=self.execute_commands)
        self.execute_button.grid(row=11, column=0, padx=5, pady=2, sticky="ew")

    def create_scenario(self):
        scenario_name = self.scenario_entry.get()
        checkbox_value = bool(self.check_var.get())
        print(f"Creating scenario: {scenario_name} | Reduce data flag: {checkbox_value}")
        if scenario_name in self.scenarios or len(scenario_name) < 1:
            messagebox.showinfo("Creation Fail", f"Cannot create scenario with name \'{scenario_name}\'. Please choose a unique name with at least 1 character.")
        else:
            # Create scenario
            # Define the path where the scenario folder will be created
            scenario_folder = os.path.join("./demo_data/", scenario_name)
            try:
                os.makedirs(scenario_folder, exist_ok=True)
                print(f"Created directory: {scenario_folder}")
            except Exception as e:
                print(f"Error creating directory {scenario_folder}: {e}")
                return
            print(f"Created scenario: {scenario_name}")
            data_file = DEFAULT_DATA_PATHS[0] if not checkbox_value else DEFAULT_DATA_PATHS[1]
            xz_io_file = os.path.join(scenario_folder, "xz_cache.csv")
            self.scenarios[scenario_name] = {
                "SEGMENTATION_DIR": "../VOLUME_SEGMENTATION/",
                "SEG_IN_FILE": data_file,
                "TEMP_REDUCED_FILE": os.path.join(scenario_folder, scenario_name + "_ROIS_REDUCED.csv"),
                "SEG_XZ_IO_FILE": xz_io_file,
                "RESTRICTED_MODE": True, # Flag on which volumetric seg algorithm to use
                "RUN_SEGMENTATION": True, # Flag to run a segmentation
                "HAS_VALIDATION": False, # Set after volume seg tool is run with some output
                "HAS_ALGORITHMIC": False, # Set after an algorithmic seg is run
                "HAS_REDUCED_DATASET": False, # Set when dataset reduction occurs
                "REMAP_VOLUMES" : True, # A mapping should be generated for a new dataset
                "SEGMENT_VALIDATED_ONLY": bool(self.reduce_var.get()),
                "REQUIRES_REDUCED_DATASET": bool(self.reduce_var.get()),
                "PLOT_TYPE": "None",
                "VALIDATION_DIR": "../VALIDATION",
                "V_DATA_FOLDER": scenario_folder,
                "V_TEMP_REDUCED_FILE": scenario_name + "_VOLUMES_REDUCED.csv",
                "V_GT_CSV": "", # Generated by running volume seg tool
                "V_ALGO_CSV": "", # Generated by running algorithmic seg tool
                "V_MAPPING_CSV": "mapping.csv",
                "algo_parameters" : {
                    "use_flat_centroid" : USE_FLAT_CENTROID,
                    "use_perc_centroid" : USE_PERC_CENTROID,
                    "use_z_threshold" : USE_Z_THRESHOLD,
                    "use_area_restriction" : USE_AREA_RESTRICTION,
                    "use_xy_restriction": USE_XY_RESTRICTION,
                    "num_projection_points" : NUM_PROJECTION_POINTS,
                    "flat_centroid_dist" : FLAT_CENTROID_DIST,
                    "perc_centroid_dist" : PERC_CENTROID_DIST,
                    "match_z_threshold" : MATCH_Z_THRESHOLD,
                    "area_delta_perc" : AREA_DELTA_PERC,
                    "use_area_deriv_restriction": RESTRICT_AREA_CHANGE,
                    "ar_change_perc": AR_CHANGE_PERC,
                    "ar_change_num_samples": AR_CHANGE_NUM_SAMPLES,
                    "ar_change_activation_thresh": AR_CHANGE_ACTIVATION_THRESH
                }
            }
            self.update_dropdown()

    def cell_merger_tool(self):
        print("Opening Cell Merger Tool...")
        # Save current scenarios
        self.save_scenarios_to_json(filepath=SCENARIOS_PATH)
        # Get current data path
        cell_data_path = self.scenarios[self.active_scenario]['SEG_IN_FILE']
        if cell_data_path in DEFAULT_DATA_PATHS:
            exit_path = os.path.join("./demo_data/", self.active_scenario, self.active_scenario + "_ROIS.csv")
        else:
            exit_path = cell_data_path
        # Run cell merger tool
        exec_args = ['python', CELL_MERGER_PATH,
                     '--cell_data_path', cell_data_path,
                     '--tif_file_path', "../GUI/tif_data/file_00001.tif",
                     '--scenarios_path', SCENARIOS_PATH,
                     '--active_scenario', self.active_scenario,
                     '--autosave_exit_path', exit_path,
                     '--up_img_path', "../GUI/up_button.png",
                     '--down_img_path', "../GUI/down_button.png"
                     ] 
        
        threading.Thread(target=self.run_subprocess, args=(exec_args, "cell_merger_tool")).start()
        self.check_queue()

    def volume_segmenter_tool(self):
        print("Opening Volume Segmenter Tool...")
        # Save current scenarios
        self.save_scenarios_to_json(filepath=SCENARIOS_PATH)
        if self.scenarios[self.active_scenario]['HAS_VALIDATION']:
            autosave_name = self.scenarios[self.active_scenario]['V_GT_CSV']
            cell_data_path = os.path.join(self.scenarios[self.active_scenario]['V_DATA_FOLDER'], autosave_name)
        else:
            cell_data_path = self.scenarios[self.active_scenario]['SEG_IN_FILE']
            autosave_name = self.active_scenario + "_VOLUMES.csv"
        exit_path = os.path.join(self.scenarios[self.active_scenario]['V_DATA_FOLDER'], autosave_name)
        # Run volume segmentation tool
        exec_args = ['python', VOLUME_SEGMENTER_PATH,
                     '--cell_data_path', cell_data_path,
                     '--tif_file_path', "../GUI/tif_data/file_00001.tif",
                     '--scenarios_path', SCENARIOS_PATH,
                     '--active_scenario', self.active_scenario,
                     '--autosave_exit_path', exit_path,
                     '--autosave_name', autosave_name,
                     '--up_img_path', "../GUI/up_button.png",
                     '--down_img_path', "../GUI/down_button.png",
                     '--eye_open_img_path', "../GUI/eye_open.png",
                     '--eye_closed_img_path', "../GUI/eye_closed.png"
                     ] 
        if cell_data_path in DEFAULT_DATA_PATHS:
            print("Adding bonus arg to export data to new folder")
            roi_exit_path = os.path.join("./demo_data/", self.active_scenario, self.active_scenario + "_ROIS.csv")
            exec_args.extend(['--roi_exit_path', roi_exit_path])
        threading.Thread(target=self.run_subprocess, args=(exec_args, "volume_segmenter_tool")).start()
        self.check_queue()

    # Updates the dictionary of a scenario with its algorithm parameters
    def update_algo_parameters(self, event = None, checkbox_name = None):
        if not self.scenarios[self.active_scenario]['RESTRICTED_MODE']:
            return
        algo_parameters = self.scenarios[self.active_scenario]["algo_parameters"]
        # Handle conflicting centroid presses
        if checkbox_name == "flat" and self.perc_centroid_check_var.get():
            self.perc_centroid_check_var.set(0)
        elif checkbox_name == "perc" and self.flat_centroid_check_var.get():
            self.flat_centroid_check_var.set(0)
        # Update checkbox variables
        algo_parameters['use_flat_centroid'] = bool(self.flat_centroid_check_var.get())
        algo_parameters['use_perc_centroid'] = bool(self.perc_centroid_check_var.get())
        algo_parameters['use_z_threshold'] = bool(self.match_z_check_var.get())
        algo_parameters['use_area_restriction'] = bool(self.restrict_area_check_var.get())
        algo_parameters['use_xy_restriction'] = bool(self.xy_restrict_check_var.get())
        algo_parameters['use_area_deriv_restriction'] = bool(self.enable_mode_check_var.get())
        # Update entry variables if applicable
        entries = [self.flat_centroid_entry, self. perc_centroid_entry, self.match_z_entry,
                   self.restrict_area_entry, self.num_points_entry, 
                   self.percent_diff_entry, self.num_xy_rois_entry, self.min_samples_entry]
        ranges = [(0,100), (0,1000), (0, 150), 
                  (0,1000), (100,500), 
                  (0,1000), (0,100), (0,100)]
        keys = ["flat_centroid_dist", "perc_centroid_dist", "match_z_threshold", 
                "area_delta_perc", "num_projection_points", 
                "ar_change_perc", "ar_change_num_samples", "ar_change_activation_thresh"]
        int_keys = {"num_projection_points", "ar_change_num_samples", "ar_change_activation_thresh",
                    "match_z_threshold"} # Track keys to store as int instead of float
        for idx, entry in enumerate(entries): 
            value = entry.get()
            try:
                key = keys[idx]
                # Determine if the value should be an int or a float
                value_parsed = float(value)
                if key in int_keys and value_parsed.is_integer():
                    value_parsed = int(value_parsed)

                min_range, max_range = ranges[idx]
                if min_range <= value_parsed <= max_range:
                    algo_parameters[key] = value_parsed 
            except ValueError:
                print(f"Please enter a valid number.")
        pass

    # Loads algorithm parameters and sets values of widgets
    def load_algo_parameters(self):
        if not self.active_scenario:
            return
        algo_parameters = self.scenarios[self.active_scenario]['algo_parameters']
        if algo_parameters["use_flat_centroid"] and algo_parameters["use_perc_centroid"]:
            algo_parameters["use_perc_centroid"] = False # only allow one centroid restriction
        # CHECKBOX UPDATES
        self.flat_centroid_check_var.set(1 if algo_parameters["use_flat_centroid"] else 0)
        self.perc_centroid_check_var.set(1 if algo_parameters["use_perc_centroid"] else 0)
        self.match_z_check_var.set(1 if algo_parameters["use_z_threshold"] else 0)
        self.restrict_area_check_var.set(1 if algo_parameters["use_area_restriction"] else 0)
        self.xy_restrict_check_var.set(1 if algo_parameters["use_xy_restriction"] else 0)
        self.enable_mode_check_var.set(1 if algo_parameters["use_area_deriv_restriction"] else 0)
        # ENTRY UPDATES
        self.num_points_entry.delete(0, tk.END)
        self.num_points_entry.insert(0, str(algo_parameters["num_projection_points"]))
        self.match_z_entry.delete(0, tk.END)
        self.match_z_entry.insert(0, str(algo_parameters["match_z_threshold"]))
        self.flat_centroid_entry.delete(0, tk.END)
        self.flat_centroid_entry.insert(0, str(algo_parameters["flat_centroid_dist"]))
        self.perc_centroid_entry.delete(0, tk.END)
        self.perc_centroid_entry.insert(0, str(algo_parameters["perc_centroid_dist"]))
        self.restrict_area_entry.delete(0, tk.END)
        self.restrict_area_entry.insert(0, str(algo_parameters["area_delta_perc"]))
        # Experimental vars
        self.percent_diff_entry.delete(0, tk.END)
        self.percent_diff_entry.insert(0, str(algo_parameters["ar_change_perc"]))
        self.num_xy_rois_entry.delete(0, tk.END)
        self.num_xy_rois_entry.insert(0, str(algo_parameters["ar_change_num_samples"]))
        self.min_samples_entry.delete(0, tk.END)
        self.min_samples_entry.insert(0, str(algo_parameters["ar_change_activation_thresh"]))

    def generate_data_plot(self, slices=SHOW_Z_SLICES):
        if not self.active_scenario:
            return
        print("Generating Data Plot")
        data = pd.read_csv(self.scenarios[self.active_scenario]["SEG_IN_FILE"])
        
        # Ensure the file has the required columns
        required_columns = {'x', 'y', 'z', 'ROI_ID'}
        if not required_columns.issubset(data.columns):
            raise ValueError(f"CSV must contain the following columns: {required_columns}")
        
        z_slices = []
        if slices:
            min_z = int(data['z'].min())
            max_z = int(data['z'].max())
            midpoint_z = int((min_z + max_z) // 2) 
            
            # Create the list of z-slices
            z_slices = [min_z, midpoint_z, max_z]
            
            # Remove duplicates, if any
            z_slices = list(sorted(set(z_slices)))


        # Check the total number of points
        total_points = len(data)
        if total_points > MAX_SAMPLE_POINTS:
            # Subsample points
            sample_frac = MAX_SAMPLE_POINTS / total_points
            data = data.sample(frac=sample_frac, random_state=42)
        
        # Create a new column for color grouping (combining z and ROI_ID)
        data['color_group'] = data.apply(lambda row: (row['z'], row['ROI_ID']), axis=1)
        
        # Generate unique colors for each (z, ROI_ID) pair
        unique_groups = data['color_group'].unique()
        colors = plt.cm.jet(np.linspace(0, 1, len(unique_groups)))  # Color map with distinct colors
        
        # Map each (z, ROI_ID) combination to a color
        color_map = {group: color for group, color in zip(unique_groups, colors)}
        data['color'] = data['color_group'].map(color_map)
        
        # Read the 3D TIFF file
        image_3d = tifffile.imread("../GUI/tif_data/file_00001.tif")

        # Create the 3D plot
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')

        # Ensure each z_slice is valid
        for z_slice in z_slices:
            if z_slice < 0 or z_slice >= image_3d.shape[0]:
                raise ValueError(f"Invalid z_slice. Must be between 0 and {image_3d.shape[0]-1}")
            
            # Extract the 2D image at the specified z slice
            image_slice = image_3d[z_slice, :, :]
            
            # Reduce the resolution if needed for performance
            downscale_factor = 20 
            image_slice_downscaled = image_slice[::downscale_factor, ::downscale_factor]
            
            # Create a grid for the image slice
            xlim, ylim = image_slice.shape[1], image_slice.shape[0]
            X_downscaled, Y_downscaled = np.meshgrid(
                np.linspace(0, xlim, image_slice_downscaled.shape[1]),
                np.linspace(0, ylim, image_slice_downscaled.shape[0])
            )
            Z_downscaled = np.full_like(X_downscaled, z_slice)  # Place the image at z_slice
        
            # Normalize image data for plotting
            image_slice_normalized = image_slice_downscaled / image_slice_downscaled.max() if image_slice_downscaled.max() != 0 else image_slice_downscaled
            
            # Use plot_surface to display the image slice at the correct scale
            ax.plot_surface(X_downscaled, Y_downscaled, Z_downscaled, rstride=1, cstride=1, facecolors=plt.cm.gray(image_slice_normalized), shade=False)
        
        # Plot each point in 3D
        ax.scatter(data['x'], data['y'], data['z'], c=data['color'], s=5)
        
        # Add labels and title
        ax.set_xlabel('X axis')
        ax.set_ylabel('Y axis')
        ax.set_zlabel('Z axis')
        ax.set_title(f"Raw ROI Input Data for Segmentation")
        
        plt.show()

    # Run set of commands on a scenario
    def execute_commands(self):
        # Update the algorithm parameters to the latest valid values stored
        self.update_algo_parameters()
        # Save current scenarios
        self.save_scenarios_to_json(filepath=SCENARIOS_PATH)
        exec_args = [
            'python', 'run_segmentation_demo.py',  
            '--scenarios_file', SCENARIOS_PATH,
            '--scenario_name', self.active_scenario,
        ]
        # Remove the XZ cache if desired
        if self.remake_xz.get() and os.path.exists(self.scenarios[self.active_scenario]["SEG_XZ_IO_FILE"]):
            print("Removed XZ Cache")
            os.remove(self.scenarios[self.active_scenario]["SEG_XZ_IO_FILE"])
        # Start the subprocess in a new thread to keep the GUI responsive
        threading.Thread(target=self.run_subprocess, args=[exec_args, "execute_commands"]).start()
        self.check_queue()

    def open_playground(self):
        pg_args = [
            'python', '../3D_SIMULATOR/3dtest7.py'
        ]
        # Start the subprocess
        threading.Thread(target=self.run_subprocess, args=[pg_args, "playground"]).start()
        self.check_queue()

    # Create a new thread to run the subprocess in the background
    def run_subprocess(self, exec_args, tool_name):
        """Run the subprocess and put the result in the queue."""
        try:
            # Run the subprocess with the list of command-line arguments
            subprocess.run(exec_args, check=True)
            self.result_queue.put((tool_name, "success"))
        except subprocess.CalledProcessError as e:
            self.result_queue.put((tool_name, f"error: {e}"))

    def check_queue(self):
        """Periodically check the queue for results."""
        try:
            # Try to get the result from the queue without blocking
            tool_name, status = self.result_queue.get_nowait()  # Non-blocking get
            if status == "success":
                print(f"{tool_name} finished successfully!")
                if tool_name in ("process_noise", "cell_merger_tool", "volume_segmenter_tool", "execute_commands"):
                    # Reload scenario dict
                    self.scenarios = self.load_scenarios_from_json(filepath=SCENARIOS_PATH)
                    if tool_name == "volume_segmenter_tool":
                        # Check to see if merging is desired
                        auto_merge = self.merge_var.get()
                        if auto_merge:
                            # Modify the validation file directly to merge rois in same volume and z
                            v_out_file = os.path.join(self.scenarios[self.active_scenario]["V_DATA_FOLDER"],self.scenarios[self.active_scenario]["V_GT_CSV"])
                            # Modify segmentation file directly as well
                            s_out_file = self.scenarios[self.active_scenario]["SEG_IN_FILE"]
                            self.process_data(merge = True, reduce = False, v_out = v_out_file, s_out = s_out_file, temp=False)
                    # Update info checkboxes, which will update info labels
                    self.update_scenario_from_checkboxes()
            else:
                print(f"Error occurred in {tool_name}: {status}")
        except queue.Empty:
            # If no result yet, check again after 100ms
            self.root.after(100, self.check_queue)

    def process_data(self, merge = False, reduce = False, v_out = None, s_out = None, temp = False):
        if merge or reduce:
            print(f"Performing reduction on datasets for {self.active_scenario}")
            self.save_scenarios_to_json(filepath=SCENARIOS_PATH)
            process_args = [
                'python', '../CELLPOSE_SCRIPTS/process_noise.py',  
                '--perform_grouping', str(merge),
                '--perform_reduction', str(reduce),
                '--temp_reduction', str(temp),
                '--scenarios_path', SCENARIOS_PATH,
                '--active_scenario', self.active_scenario,
                '--roi_out_path', s_out,
                '--vol_out_path', v_out
            ]
            # Start the subprocess in a new thread to keep the GUI responsive
            threading.Thread(target=self.run_subprocess, args=[process_args, "process_noise"]).start()
            self.check_queue()
            
    def reduce_data(self):
        v_out = os.path.join(self.scenarios[self.active_scenario]["V_DATA_FOLDER"],self.scenarios[self.active_scenario]["V_GT_CSV"])
        s_out = self.scenarios[self.active_scenario]["SEG_IN_FILE"]
        # Process the data by merging it, reducing it (dropping noise), and operating on real datasets
        self.process_data(merge=True, reduce=True, v_out=v_out, s_out=s_out, temp=False)

    def update_reduction_button(self):
        if self.active_scenario:
            is_reduced = self.scenarios[self.active_scenario]["HAS_REDUCED_DATASET"]
            has_validation_dataset = self.scenarios[self.active_scenario]["HAS_VALIDATION"]
            if is_reduced or not has_validation_dataset:
                self.reduce_data_button.config(state="disabled", bg='darkgray')
            else:
                self.reduce_data_button.config(state="normal", bg='orange')
            # Execute button logic
            if self.seg_var.get() or self.algo_var.get() or self.gt_var.get():
                self.execute_button.config(state = "normal", bg = "lightgreen")
            else:
                self.execute_button.config(state = "disabled", bg = "darkgray")


    def update_scenario_from_checkboxes(self):
        """Updates the scenario dictionary based on the checkbox states."""
        if self.active_scenario:
            # Check to ensure the rules are being followed and make changes if required 
            self.update_checkbox_enable_state()
            # Update the scenario dictionary with checkbox values
            self.scenarios[self.active_scenario]["RESTRICTED_MODE"] = bool(self.ffp_var.get())
            self.scenarios[self.active_scenario]["RUN_SEGMENTATION"] = bool(self.seg_var.get())
            self.scenarios[self.active_scenario]["SEGMENT_VALIDATED_ONLY"] = bool(self.run_reduced_var.get())
            self.scenarios[self.active_scenario]["REMAP_VOLUMES"] = bool(self.mapping_var.get())
            if self.algo_var.get() and self.gt_var.get():
                self.scenarios[self.active_scenario]["PLOT_TYPE"] = "both"
            elif self.algo_var.get(): 
                self.scenarios[self.active_scenario]["PLOT_TYPE"] = "algo"
            elif self.gt_var.get():
                self.scenarios[self.active_scenario]["PLOT_TYPE"] = "gt"
            else:
                self.scenarios[self.active_scenario]["PLOT_TYPE"] = "None"

            # Update info frame
            self.update_info_labels()
        else:
            print("No active scenario to update.")

    def load_scenario(self):
        scenario_name = self.scenario_combobox.get()
        print(f"Loading scenario: {scenario_name}")
        if scenario_name in self.scenarios:
            print(f"Successfully loaded scenario: {scenario_name}")
            self.active_scenario = scenario_name
             # Display the active scenario title
            self.active_scenario_label.config(text=f"Active Scenario: {scenario_name}")

            # Show the upper and lower right frames when a scenario is active
            self.upper_right_frame.grid()  # Make upper frame visible
            self.lower_right_frame.grid()  # Make lower frame visible

            # Encourage users to use their cache
            if os.path.exists(self.scenarios[self.active_scenario]["SEG_XZ_IO_FILE"]):
                self.remake_xz.set(0)

            # Clear existing labels
            for widget in self.left_info_frame.winfo_children():
                widget.destroy()
            for widget in self.right_info_frame.winfo_children():
                widget.destroy()

            # Get scenario data
            scenario_data = self.scenarios[scenario_name]

            # Add labels for keys (left-justified) and values (right-justified)
            for idx, (key, value) in enumerate(scenario_data.items()):
                # Add key label (right-justified)
                key_label = tk.Label(self.left_info_frame, text=f"{key}:", anchor="e", justify="right")
                key_label.grid(row=idx, column=0, sticky="e", padx=5, pady=2)

                # Add value label (left-justified)
                value_label = tk.Label(self.right_info_frame, text=str(value), anchor="w", justify="left")
                value_label.grid(row=idx, column=1, sticky="w", padx=5, pady=2)
        
            # Update checkbox labels
            if self.scenarios[self.active_scenario]["PLOT_TYPE"].lower() == "both": # Plot both
                self.gt_var.set(1)
                self.algo_var.set(1)
            elif self.scenarios[self.active_scenario]["PLOT_TYPE"].lower() == "algo": # Plot algo
                self.gt_var.set(0)
                self.algo_var.set(1)
            elif self.scenarios[self.active_scenario]["PLOT_TYPE"].lower() == "gt": # Plot gt
                self.gt_var.set(1)
                self.algo_var.set(0)
            else: # Plot none
                self.gt_var.set(0)
                self.algo_var.set(0)
            self.ffp_var.set(1 if scenario_data.get("RESTRICTED_MODE", None) else 0)
            self.seg_var.set(1 if scenario_data.get("RUN_SEGMENTATION", None) else 0)
            self.run_reduced_var.set(1 if scenario_data.get("SEGMENT_VALIDATED_ONLY", None) else 0)
            self.mapping_var.set(1 if scenario_data.get("REMAP_VOLUMES", None) else 0)

            # Update ffp algorithm GUI widgets
            self.load_algo_parameters()
            
            self.update_scenario_from_checkboxes()
        else:
            print(f"Unable to load scenario: {scenario_name}")

    def update_checkbox_enable_state(self):
        scenario_data = self.scenarios[self.active_scenario]
        # Show algorithm parameters if FFP used
        if self.ffp_var.get():
            self.algorithm_frame.grid()
        else:
            self.algorithm_frame.grid_remove()
        # May only view GT if a validation set has been generated
        if scenario_data.get("HAS_VALIDATION", False):
            self.gt_checkbox.config(state="normal")
        else:
            self.gt_checkbox.config(state="disabled")
            self.gt_var.set(0)

        if not os.path.exists(self.scenarios[self.active_scenario]["SEG_XZ_IO_FILE"]):
            self.remake_xz.set(1)
            self.xz_checkbox.config(state="disabled")
        else:
            self.xz_checkbox.config(state="normal")

        # If no data reduction has happened, a volume segmentation cannot be run on main dataset - generates temporary one
        if scenario_data.get("REQUIRES_REDUCED_DATASET", False) and not scenario_data.get("HAS_REDUCED_DATASET", False):
            self.run_reduced_var.set(1)
            self.run_reduce_checkbox.config(state="disabled")
        elif scenario_data.get("REQUIRES_REDUCED_DATASET", False) and scenario_data.get("HAS_REDUCED_DATASET", False):
            self.run_reduced_var.set(0)
            self.run_reduce_checkbox.config(state="disabled")
        else:
            self.run_reduce_checkbox.config(state="normal")

        # Disable segmentation if no validation, a requirement for reduction, and no reduction present
        if not scenario_data.get("HAS_VALIDATION", False) and scenario_data.get("REQUIRES_REDUCED_DATASET", False) and not scenario_data.get("HAS_REDUCED_DATASET", False):
            self.seg_var.set(0)
            self.seg_checkbox.config(state="disabled")
        else:
            self.seg_checkbox.config(state="normal")

        # Allow a user to not remap volumes iff there is a validation and algorithmic already
        if not scenario_data.get("HAS_VALIDATION", None) or not scenario_data.get("HAS_ALGORITHMIC", None) or self.seg_var.get():
            self.mapping_var.set(1)
            self.mapping_checkbox.config(state="disabled")
        else:
            self.mapping_checkbox.config(state="normal")

        # Can only view an algorithmic volume if it has been generated
        if scenario_data.get("HAS_ALGORITHMIC", False) or self.seg_var.get():
            self.algo_checkbox.config(state="normal")
        else:
            self.algo_checkbox.config(state="disabled")
            self.algo_var.set(0)
        
        

    def update_info_labels(self):
        """Update the labels in the right frame of the inner left frame to reflect the current scenario values."""
        if self.active_scenario:
            # Clear existing labels in the right info frame
            for widget in self.right_info_frame.winfo_children():
                widget.destroy()

            # Get the updated scenario data
            scenario_data = self.scenarios[self.active_scenario]

            # Add updated labels for the values
            for idx, (key, value) in enumerate(scenario_data.items()):
                display_value = str(value)
                if len(display_value) > MAX_LABEL_WIDTH:
                    display_value = display_value[:MAX_LABEL_WIDTH - 3] + "..." 

                # Create the label with a fixed width and wrapping
                value_label = tk.Label(self.right_info_frame, text=display_value, anchor="w", justify="left", width=MAX_LABEL_WIDTH)
                value_label.grid(row=idx, column=1, sticky="w", padx=5, pady=2)

            # Update other fields
            self.update_reduction_button()
        else:
            print("No active scenario to display.")
        

    def on_closing(self):
        # Export scenarios json
        if SAVE_SCENARIOS_ON_CLOSE:
            self.save_scenarios_to_json(filepath=SCENARIOS_PATH)
        self.root.quit()
        self.root.destroy()

    def save_scenarios_to_json(self, filepath):
        """Save the current scenarios dictionary to the JSON file."""
        try:
            with open(filepath, 'w') as file:
                json.dump(self.scenarios, file, indent=4)
                print(f"Scenarios saved to {filepath}")
        except Exception as e:
            print(f"Error saving scenarios: {e}")

    def load_scenarios_from_json(self, filepath):
        """Load scenarios from a JSON file and return a dictionary."""
        try:
            with open(filepath, 'r') as file:
                scenarios = json.load(file)
                return scenarios
        except FileNotFoundError:
            print(f"Error: File '{filepath}' not found.")
            return {}
        
    def update_dropdown(self, event=None):
        """Optionally filter the dropdown values based on user input."""
        typed_value = self.scenario_combobox.get()
        if typed_value == '':
            # Show all options if the box is empty
            self.scenario_combobox['values'] = list(self.scenarios.keys())
        else:
            # Filter based on typed input
            filtered_scenarios = [key for key in self.scenarios if typed_value.lower() in key.lower()]
            self.scenario_combobox['values'] = filtered_scenarios

if __name__ == "__main__":
    root = tk.Tk()
    app = DemoGUIApp(root)
    root.mainloop()
