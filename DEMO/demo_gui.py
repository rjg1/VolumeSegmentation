import tkinter as tk
from tkinter import ttk, messagebox
import json
import os
import subprocess
import queue
import threading

# Relative path to scenarios json
SCENARIOS_PATH = "./scenarios.json"
# Outlines of masks generated by cellpose on a DRG dataset
RAW_DATA_PATH = "../GUI/cell_data/roi_coordinates_2.csv"
# Outlines of masks generated by cellpose on a DRG dataset, after which a pre-processing merge step was applied
MERGED_DATA_PATH = "../GUI/cell_data/ROI_coordinates_20241003_x300_800_y0_500_z1_38.csv"
# Path to cell merger tool
CELL_MERGER_PATH = "../GUI/cell_merger.py"
# Path to volume segmenter tool
VOLUME_SEGMENTER_PATH = "../GUI/manual_seg.py"
# Force new scenarios to reduce data first
FORCE_REQUIRE_REDUCED_DATA = True
# Save scenarios json on close
SAVE_SCENARIOS_ON_CLOSE = False
# Data paths to default data used
DEFAULT_DATA_PATHS = [RAW_DATA_PATH, MERGED_DATA_PATH]


class DemoGUIApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Scenario Manager")
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.result_queue = queue.Queue()  # For thread results
        # Get the scenarios dictionary
        self.scenarios = self.load_scenarios_from_json(SCENARIOS_PATH)
        self.active_scenario = None # No active scenario on startup

        # Create scenario section
        self.create_label = tk.Label(self.root, text="Create scenario", font=("Arial", 12, "bold"))
        self.create_label.grid(row=0, column=0, padx=5, pady=10, sticky="w")

        # Create a frame to hold the entry, checkboxes, and button
        self.entry_checkbox_frame = tk.Frame(self.root)
        self.entry_checkbox_frame.grid(row=1, column=0, columnspan=4, padx=5, pady=5, sticky="w")

        # Create scenario name entry inside the frame
        self.scenario_entry = tk.Entry(self.entry_checkbox_frame, width=30)
        self.scenario_entry.pack(side="left", padx=1, pady=1)
        
        # Checkbox for using merged data inside the frame
        self.check_var = tk.IntVar(value=1)
        self.scenario_checkbox = tk.Checkbutton(self.entry_checkbox_frame, text="Use pre-processed data", variable=self.check_var)
        self.scenario_checkbox.pack(side="left", padx=1, pady=1)

        # Checkbox for requiring data to be reduced inside the frame
        self.reduce_var = tk.IntVar(value=1)
        self.reduce_checkbox = tk.Checkbutton(self.entry_checkbox_frame, text="Require Data Reduction", variable=self.reduce_var)
        self.reduce_checkbox.pack(side="left", padx=1, pady=1)
        if FORCE_REQUIRE_REDUCED_DATA:
            self.reduce_checkbox.config(state='disabled')

        # Create button inside the frame
        self.create_button = tk.Button(self.entry_checkbox_frame, text="Create", command=self.create_scenario, width=10)
        self.create_button.pack(side="left", padx=5, pady=1)

        # Load scenario section
        self.load_label = tk.Label(self.root, text="Load scenario", font=("Arial", 12, "bold"))
        self.load_label.grid(row=3, column=0, padx=5, pady=10, sticky="w")

        # Create a frame to hold the dropdown and load button
        self.dropdown_frame = tk.Frame(self.root)
        self.dropdown_frame.grid(row=4, column=0, columnspan=3, padx=5, pady=5, sticky="w")

        # Dropdown for loading scenario inside the frame
        self.scenario_combobox = ttk.Combobox(self.dropdown_frame, values=list(self.scenarios.keys()), width=27)
        self.scenario_combobox.pack(side="left", padx=1, pady=1)
        self.scenario_combobox.set('')  # Placeholder text
        self.scenario_combobox.bind("<KeyRelease>", self.update_dropdown)

        # Load button inside the frame
        self.load_button = tk.Button(self.dropdown_frame, text="Load", command=self.load_scenario, width=10)
        self.load_button.pack(side="left", padx=5, pady=1)
        
        # Label for active scenario
        self.active_scenario_label = tk.Label(self.root, text="No Active Scenario", font=("Arial", 12, "bold"))
        self.active_scenario_label.grid(row=5, column=0, padx=10, pady=10, sticky="w")

        # Outer frame (contains the inner left/right frames)
        self.outer_frame = ttk.Frame(self.root, width=600, height=300, relief=tk.SUNKEN)
        self.outer_frame.grid(row=6, column=0, columnspan=3, padx=5, pady=20, sticky="nsew")

        # Inner left frame (contains keys/values, split into two subframes)
        self.inner_left_frame = tk.Frame(self.outer_frame, width=400)  # Fixed width
        self.inner_left_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        # Inner right frame (options, placeholder for now)
        self.inner_right_frame = tk.Frame(self.outer_frame, width=200)  # Fixed width
        self.inner_right_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")

        # Split inner left frame into two subframes for keys and values
        self.left_info_frame = tk.Frame(self.inner_left_frame, width=200)
        self.left_info_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        self.right_info_frame = tk.Frame(self.inner_left_frame, width=200)
        self.right_info_frame.grid(row=0, column=1, padx=10, pady=10, sticky="nsew")

        # Configure grid to ensure proper layout
        self.outer_frame.grid_columnconfigure(0, weight=1)
        self.outer_frame.grid_columnconfigure(1, weight=1)

        # Upper and lower frame inside the right inner frame (for tools and commands)
        self.upper_right_frame = tk.Frame(self.inner_right_frame, width=200)
        self.upper_right_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        self.upper_right_frame.grid_remove()  # Hide initially

        self.lower_right_frame = tk.Frame(self.inner_right_frame, width=200)
        self.lower_right_frame.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")
        self.lower_right_frame.grid_remove()  # Hide initially

        # Upper frame content (Tools label and buttons)
        tools_label = tk.Label(self.upper_right_frame, text="Tools", font=("Arial", 12, "bold"))
        tools_label.grid(row=0, column=0, padx=10, pady=10)

        self.upper_right_frame.grid_columnconfigure(0, weight=1)

        data_view_button = tk.Button(self.upper_right_frame, text="Raw Data Viewer", width=15, command=self.generate_data_plot)
        data_view_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew") 

        cell_merger_button = tk.Button(self.upper_right_frame, text="Cell Merger", width=15, command=self.cell_merger_tool)
        cell_merger_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew")  

        volume_segmenter_button = tk.Button(self.upper_right_frame, text="Volume Segmenter", width=15, command=self.volume_segmenter_tool)
        volume_segmenter_button.grid(row=3, column=0, padx=5, pady=5, sticky="ew")  

        # Checkbox for requiring data to be reduced inside the frame
        self.reduce_var2 = tk.IntVar(value=1)
        self.reduce_checkbox2 = tk.Checkbutton(self.upper_right_frame, text="Reduce data on exit", variable=self.reduce_var2)
        self.reduce_checkbox2.grid(row=4, column=0, padx=5, pady=0, sticky="ew")
        if FORCE_REQUIRE_REDUCED_DATA:
            self.reduce_checkbox2.config(state='disabled')

        # Lower frame content (Commands label, checkboxes, and execute button)
        commands_label = tk.Label(self.lower_right_frame, text="Commands", font=("Arial", 12, "bold"))
        commands_label.grid(row=0, column=0, padx=10, pady=10)

        self.lower_right_frame.grid_columnconfigure(0, weight=1)

        # Checkboxes for different commands
        self.ffp_var = tk.IntVar()
        self.seg_var = tk.IntVar()
        self.gt_var = tk.IntVar()
        self.algo_var = tk.IntVar()

        self.ffp_checkbox = tk.Checkbutton(self.lower_right_frame, text="Use Fit-For-Purpose Algorithm", variable=self.ffp_var, command=self.update_scenario_from_checkboxes)
        self.ffp_checkbox.grid(row=1, column=0, sticky="w", padx=5, pady=2)

        self.seg_checkbox = tk.Checkbutton(self.lower_right_frame, text="Run Volume Segmentation", variable=self.seg_var, command=self.update_scenario_from_checkboxes)
        self.seg_checkbox.grid(row=2, column=0, sticky="w", padx=5, pady=2)

        self.gt_checkbox = tk.Checkbutton(self.lower_right_frame, text="View Ground Truth Volumes", variable=self.gt_var, command=self.update_scenario_from_checkboxes)
        self.gt_checkbox.grid(row=3, column=0, sticky="w", padx=5, pady=2)

        self.algo_checkbox = tk.Checkbutton(self.lower_right_frame, text="View Algorithmic Volumes", variable=self.algo_var, command=self.update_scenario_from_checkboxes)
        self.algo_checkbox.grid(row=4, column=0, sticky="w", padx=5, pady=2)

        # Execute button with fixed width
        execute_button = tk.Button(self.lower_right_frame, text="Execute", width=15, command=self.execute_commands)
        execute_button.grid(row=5, column=0, padx=5, pady=10, sticky="ew")

    def create_scenario(self):
        scenario_name = self.scenario_entry.get()
        checkbox_value = bool(self.check_var.get())
        print(f"Creating scenario: {scenario_name} | Merge data flag: {checkbox_value}")
        if scenario_name in self.scenarios or len(scenario_name) < 1:
            messagebox.showinfo("Creation Fail", f"Cannot create scenario with name \'{scenario_name}\'. Please choose a unique name with at least 1 character.")
        else:
            # Create scenario
            # Define the path where the scenario folder will be created
            scenario_folder = os.path.join("./demo_data/", scenario_name)
            try:
                os.makedirs(scenario_folder, exist_ok=True)
                print(f"Created directory: {scenario_folder}")
            except Exception as e:
                print(f"Error creating directory {scenario_folder}: {e}")
                return
            print(f"Created scenario: {scenario_name}")
            data_file = DEFAULT_DATA_PATHS[0] if not checkbox_value else DEFAULT_DATA_PATHS[1]
            xz_io_file = os.path.join(scenario_folder, "xz_cache.csv")
            self.scenarios[scenario_name] = {
                "SEGMENTATION_DIR": "../VOLUME_SEGMENTATION/",
                "SEG_IN_FILE": data_file,
                "SEG_XZ_IO_FILE": xz_io_file,
                "RESTRICTED_MODE": True, # Flag on which volumetric seg algorithm to use
                "RUN_SEGMENTATION": True, # Flag to run a segmentation
                "HAS_VALIDATION": False, # Set after volume seg tool is run with some output
                "HAS_ALGORITHMIC": False, # Set after an algorithmic seg is run
                "HAS_REDUCED_DATASET": False, # Set when dataset reduction occurs
                "REQUIRES_REDUCED_DATASET": bool(self.reduce_var.get()),
                "PLOT_TYPE": "None",
                "VALIDATION_DIR": "../VALIDATION",
                "V_DATA_FOLDER": scenario_folder,
                "V_GT_CSV": "", # Generated by running volume seg tool
                "V_ALGO_CSV": "", # Generated by running algorithmic seg tool
                "V_MAPPING_CSV": "mapping.csv"
            }

    def cell_merger_tool(self):
        print("Opening Cell Merger Tool...")
        # Save current scenarios
        self.save_scenarios_to_json(filepath=SCENARIOS_PATH)
        # Get current data path
        cell_data_path = self.scenarios[self.active_scenario]['SEG_IN_FILE']
        if cell_data_path in DEFAULT_DATA_PATHS:
            exit_path = os.path.join("./demo_data/", self.active_scenario, self.active_scenario + "_ROIS.csv")
        else:
            exit_path = cell_data_path
        # Run cell merger tool
        exec_args = ['python', CELL_MERGER_PATH,
                     '--cell_data_path', cell_data_path,
                     '--tif_file_path', "../GUI/tif_data/file_00001.tif",
                     '--scenarios_path', SCENARIOS_PATH,
                     '--active_scenario', self.active_scenario,
                     '--autosave_exit_path', exit_path,
                     '--up_img_path', "../GUI/up_button.png",
                     '--down_img_path', "../GUI/down_button.png"
                     ] 
        
        threading.Thread(target=self.run_subprocess, args=(exec_args, "cell_merger_tool")).start()
        self.check_queue()

    def volume_segmenter_tool(self):
        print("Opening Volume Segmenter Tool...")
        # Save current scenarios
        self.save_scenarios_to_json(filepath=SCENARIOS_PATH)
        if self.scenarios[self.active_scenario]['HAS_VALIDATION']:
            cell_data_path = self.scenarios[self.active_scenario]['V_GT_CSV']
        else:
            cell_data_path = self.scenarios[self.active_scenario]['SEG_IN_FILE']
        exit_path = self.active_scenario + "_VOLUMES.csv"
        # Run volume segmentation tool
        exec_args = ['python', VOLUME_SEGMENTER_PATH,
                     '--cell_data_path', cell_data_path,
                     '--tif_file_path', "../GUI/tif_data/file_00001.tif",
                     '--scenarios_path', SCENARIOS_PATH,
                     '--active_scenario', self.active_scenario,
                     '--autosave_exit_path', exit_path,
                     '--up_img_path', "../GUI/up_button.png",
                     '--down_img_path', "../GUI/down_button.png",
                     '--eye_open_img_path', "../GUI/eye_open.png",
                     '--eye_closed_img_path', "../GUI/eye_closed.png"
                     ] 
        threading.Thread(target=self.run_subprocess, args=(exec_args, "volume_segmenter_tool")).start()
        self.check_queue()

    def generate_data_plot(self):
        print("Generating Data Plot")

    # Run set of commands on a scenario
    def execute_commands(self):
        # Save current scenarios
        self.save_scenarios_to_json(filepath=SCENARIOS_PATH)
        exec_args = [
            'python', 'run_segmentation_demo.py',  
            '--scenarios_file', SCENARIOS_PATH,
            '--scenario_name', self.active_scenario,
        ]
        # Start the subprocess in a new thread to keep the GUI responsive
        threading.Thread(target=self.run_subprocess, args=[exec_args, "execute_commands"]).start()
        self.check_queue()

    # Create a new thread to run the subprocess in the background
    def run_subprocess(self, exec_args, tool_name):
        """Run the subprocess and put the result in the queue."""
        try:
            # Run the subprocess with the list of command-line arguments
            subprocess.run(exec_args, check=True)
            self.result_queue.put((tool_name, "success"))
        except subprocess.CalledProcessError as e:
            self.result_queue.put((tool_name, f"error: {e}"))

    def check_queue(self):
        """Periodically check the queue for results."""
        try:
            # Try to get the result from the queue without blocking
            tool_name, status = self.result_queue.get_nowait()  # Non-blocking get
            if status == "success":
                print(f"{tool_name} finished successfully!")
                if tool_name in ("cell_merger_tool", "volume_segmenter_tool", "execute_commands"):
                    # Reload scenario dict
                    self.scenarios = self.load_scenarios_from_json(filepath=SCENARIOS_PATH)

                    if tool_name == "volume_segmenter_tool":
                        # TODO Check to see if reduction is required and perform it if necessary
                        pass
                    # Update info labels
                    self.update_info_labels()
                    # Update checkbox enable states
                    self.update_checkbox_enable_state()
            else:
                print(f"Error occurred in {tool_name}: {status}")
        except queue.Empty:
            # If no result yet, check again after 100ms
            self.root.after(100, self.check_queue)


    def update_scenario_from_checkboxes(self):
        """Updates the scenario dictionary based on the checkbox states."""
        if self.active_scenario:
            # Update the scenario dictionary with checkbox values
            self.scenarios[self.active_scenario]["RESTRICTED_MODE"] = bool(self.ffp_var.get())
            self.scenarios[self.active_scenario]["RUN_SEGMENTATION"] = bool(self.seg_var.get())
            if self.algo_var.get() and self.gt_var.get():
                self.scenarios[self.active_scenario]["PLOT_TYPE"] = "both"
            elif self.algo_var.get(): 
                self.scenarios[self.active_scenario]["PLOT_TYPE"] = "algo"
            elif self.gt_var.get():
                self.scenarios[self.active_scenario]["PLOT_TYPE"] = "gt"
            else:
                self.scenarios[self.active_scenario]["PLOT_TYPE"] = "None"

            # Update info frame
            self.update_info_labels()
            self.update_checkbox_enable_state()
        else:
            print("No active scenario to update.")

    def load_scenario(self):
        scenario_name = self.scenario_combobox.get()
        print(f"Loading scenario: {scenario_name}")
        if scenario_name in self.scenarios:
            print(f"Successfully loaded scenario: {scenario_name}")
            self.active_scenario = scenario_name
             # Display the active scenario title
            self.active_scenario_label.config(text=f"Active Scenario: {scenario_name}")

            # Show the upper and lower right frames when a scenario is active
            self.upper_right_frame.grid()  # Make upper frame visible
            self.lower_right_frame.grid()  # Make lower frame visible

            # Clear existing labels
            for widget in self.left_info_frame.winfo_children():
                widget.destroy()
            for widget in self.right_info_frame.winfo_children():
                widget.destroy()

            # Get scenario data
            scenario_data = self.scenarios[scenario_name]

            # Add labels for keys (left-justified) and values (right-justified)
            for idx, (key, value) in enumerate(scenario_data.items()):
                # Add key label (right-justified)
                key_label = tk.Label(self.left_info_frame, text=f"{key}:", anchor="e", justify="right")
                key_label.grid(row=idx, column=0, sticky="e", padx=5, pady=2)

                # Add value label (left-justified)
                value_label = tk.Label(self.right_info_frame, text=str(value), anchor="w", justify="left")
                value_label.grid(row=idx, column=1, sticky="w", padx=5, pady=2)
        
            # Update checkbox labels
            if self.scenarios[self.active_scenario]["REQUIRES_REDUCED_DATASET"] and not self.scenarios[self.active_scenario]["HAS_REDUCED_DATASET"]:
                # Requires a reduction
                self.reduce_var2.set(1)
                if FORCE_REQUIRE_REDUCED_DATA:
                    self.reduce_checkbox2.config(state="disabled") # Must reduce
            else:
                self.reduce_var2.set(0)
                # Optionally may reduce
                self.reduce_checkbox2.config(state="normal")

            if self.scenarios[self.active_scenario]["PLOT_TYPE"].lower() == "both": # Plot both
                self.gt_var.set(1)
                self.algo_var.set(1)
            elif self.scenarios[self.active_scenario]["PLOT_TYPE"].lower() == "algo": # Plot algo
                self.gt_var.set(0)
                self.algo_var.set(1)
            elif self.scenarios[self.active_scenario]["PLOT_TYPE"].lower() == "gt": # Plot gt
                self.gt_var.set(1)
                self.algo_var.set(0)
            else: # Plot none
                self.gt_var.set(0)
                self.algo_var.set(0)
            self.ffp_var.set(1 if scenario_data.get("RESTRICTED_MODE", None) else 0)
            self.seg_var.set(1 if scenario_data.get("RUN_SEGMENTATION", None) else 0)
            self.update_checkbox_enable_state()
        else:
            print(f"Unable to load scenario: {scenario_name}")

    def update_checkbox_enable_state(self):
        scenario_data = self.scenarios[self.active_scenario]
        # May only view GT if a validation set has been generated
        if scenario_data.get("HAS_VALIDATION", False):
            self.gt_checkbox.config(state="normal")
        else:
            self.gt_checkbox.config(state="disabled")
            self.gt_var.set(0)

        # If no data reduction has happened, a volume segmentation cannot be run in most cases
        if scenario_data.get("REQUIRES_REDUCED_DATASET", False) and not scenario_data.get("HAS_REDUCED_DATASET", False):
            self.seg_var.set(0)
            self.seg_checkbox.config(state="disabled")
        else:
            self.seg_checkbox.config(state="normal")
            self.seg_var.set(1 if scenario_data.get("RUN_SEGMENTATION", None) else 0)

        if scenario_data.get("HAS_ALGORITHMIC", False) or self.seg_var.get():
            self.algo_checkbox.config(state="normal")
        else:
            self.algo_checkbox.config(state="disabled")
            self.algo_var.set(0)
        

    def update_info_labels(self):
        """Update the labels in the right frame of the inner left frame to reflect the current scenario values."""
        if self.active_scenario:
            # Clear existing labels in the right info frame
            for widget in self.right_info_frame.winfo_children():
                widget.destroy()

            # Get the updated scenario data
            scenario_data = self.scenarios[self.active_scenario]

            # Add updated labels for the values
            for idx, (key, value) in enumerate(scenario_data.items()):
                value_label = tk.Label(self.right_info_frame, text=str(value), anchor="w", justify="left")
                value_label.grid(row=idx, column=1, sticky="w", padx=5, pady=2)
        else:
            print("No active scenario to display.")

    def on_closing(self):
        # Export scenarios json
        if SAVE_SCENARIOS_ON_CLOSE:
            self.save_scenarios_to_json(filepath=SCENARIOS_PATH)
        self.root.quit()
        self.root.destroy()

    def save_scenarios_to_json(self, filepath):
        """Save the current scenarios dictionary to the JSON file."""
        try:
            with open(filepath, 'w') as file:
                json.dump(self.scenarios, file, indent=4)
                print(f"Scenarios saved to {filepath}")
        except Exception as e:
            print(f"Error saving scenarios: {e}")

    def load_scenarios_from_json(self, filepath):
        """Load scenarios from a JSON file and return a dictionary."""
        try:
            with open(filepath, 'r') as file:
                scenarios = json.load(file)
                return scenarios
        except FileNotFoundError:
            print(f"Error: File '{filepath}' not found.")
            return {}
        
    def update_dropdown(self, event):
        """Optionally filter the dropdown values based on user input."""
        typed_value = self.scenario_combobox.get()
        if typed_value == '':
            # Show all options if the box is empty
            self.scenario_combobox['values'] = list(self.scenarios.keys())
        else:
            # Filter based on typed input
            filtered_scenarios = [key for key in self.scenarios if typed_value.lower() in key.lower()]
            self.scenario_combobox['values'] = filtered_scenarios

if __name__ == "__main__":
    root = tk.Tk()
    app = DemoGUIApp(root)
    root.mainloop()
